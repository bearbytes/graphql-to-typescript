import ts from 'typescript'
import { SchemaIR } from '../transform/SchemaIR'
import { DocumentIR } from '../transform/DocumentIR'
import { generateOperations } from './Operation'
import prettier from 'prettier'
import { generateImport } from './Import'
import { generateScalarTypeAlias } from './ScalarType'
import { ScalarTypeIR } from '../transform/ScalarTypeIR'
import { InputObjectTypeIR } from '../transform/InputObjectTypeIR'
import { generateInputObjectTypeAsInterface } from './InputObjectType'
import { generateFragment } from './Fragment'
import { VariableIR } from '../transform/VariableIR'
import { FragmentIR } from '../transform/FragmentIR'
import { OperationIR } from '../transform/OperationIR'
import { TypeIR } from '../transform/TypeIR'

export async function generateCode(
  schema: SchemaIR,
  documents: DocumentIR[]
): Promise<string> {
  return await cleanup(
    [
      printHeader(),
      printScalarTypes(schema),
      printFragmentTypes(schema, documents),
      printInputTypes(schema, getUsedInputTypes(schema, documents)),
      printOperations(schema, documents),
    ].join('\n\n')
  )
}

const sourceFile = ts.createSourceFile('', '', ts.ScriptTarget.Latest)
const printer = ts.createPrinter()
function print(t: any) {
  return printer.printNode(ts.EmitHint.Unspecified, t, sourceFile)
}

function printScalarTypes(schema: SchemaIR): string {
  return (
    '// Scalar Types\n' +
    Object.values(schema.types)
      .filter((it) => it && it.kind == 'scalar')
      .map((it) => it as ScalarTypeIR)
      .map(generateScalarTypeAlias)
      .map(print)
      .join('\n')
  )
}

function printFragmentTypes(schema: SchemaIR, documents: DocumentIR[]): string {
  const fragments = documents.reduce<FragmentIR[]>(
    (acc, document) => acc.concat(document.fragments),
    []
  )
  if (fragments.length == 0) return ''

  return (
    '// Fragment Types\n' +
    fragments
      .map((fragment) => generateFragment(schema, fragment))
      .map(print)
      .join('\n')
  )
}

function printInputTypes(
  schema: SchemaIR,
  usedInputTypes: Record<string, true>
): string {
  const inputTypes = Object.entries(schema.types)
    .map(([typename, type]) => ({ typename, type }))
    .filter((it) => it.type && it.type.kind == 'inputObject')
    .filter((it) => usedInputTypes[it.typename])

  if (inputTypes.length == 0) return ''

  return (
    '// Input Types\n' +
    inputTypes
      .map((it) => {
        return generateInputObjectTypeAsInterface(
          schema,
          it.type as InputObjectTypeIR,
          it.typename
        )
      })
      .map(print)
      .join('\n')
  )
}

function printOperations(schema: SchemaIR, documents: DocumentIR[]) {
  return (
    '// Operations\n' +
    [generateOperations(schema, documents)].map(print).join('\n')
  )
}

function printHeader() {
  return (
    '// This file is generated by a tool. All changes will be overwritten.\n' +
    [generateImport('@bearbytes/graphql-to-typescript', undefined, 'Operation')]
      .map(print)
      .join('\n')
  )
}

async function cleanup(code: string) {
  const prettierConfig = await prettier.resolveConfig(process.cwd())
  return prettier.format(code, {
    ...prettierConfig,
    parser: 'typescript',
  })
}

function getUsedInputTypes(schema: SchemaIR, documents: DocumentIR[]) {
  const usedInputTypes: Record<string, true> = {}

  documents
    .reduce<OperationIR[]>(
      (acc, document) => acc.concat(document.operations),
      []
    )
    .reduce<VariableIR[]>(
      (acc, operation) => acc.concat(Object.values(operation.variables)),
      []
    )
    .forEach(visit)

  function visit(variable: VariableIR): void {
    switch (variable.kind) {
      case 'nonNull':
        return visit(variable.wrappedType)
      case 'list':
        return visit(variable.wrappedType)
      case 'namedType':
        return visitNamedType(variable.typename)
    }
  }

  function visitNamedType(typename: string): void {
    usedInputTypes[typename] = true
    const type = schema.types[typename]
    if (type) visitType(type)
  }

  function visitType(type: TypeIR): void {
    switch (type.kind) {
      case 'nonNull':
        return visitType(type.wrappedType)
      case 'list':
        return visitType(type.wrappedType)
      case 'inputObject':
        for (const fieldType of Object.values(type.fields)) {
          visitType(fieldType)
        }
        return
      case 'namedType':
        return visitNamedType(type.typename)
      default:
      // todo: interfaces, unions, enums
    }
  }

  return usedInputTypes
}
